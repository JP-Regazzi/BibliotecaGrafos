\documentclass[a4paper,openright, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\pagenumbering{gobble}
\usepackage[brazil]{babel}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}

\usepackage{tikz}

\usepackage{multicol}

\title{Segunda Lista - Teoria dos Grafos}
\author{João Pedro Regazzi Ferreira da Silva }
\date{DRE: 120030115}

\begin{document}

\maketitle

\section*{Questão 1}
Considerando um grafo $G = (V,E)$, número de arestas $m = |E|$ e grau do vértice $v \in V$ sendo $d_{v}$, podemos calcular $m$ em função de $d_{v}$. \par
Para tanto, devemos somar o grau de todos os vértices do grafo e, então, dividir o resultado por 2. Dessa forma, vamos contar duas vezes todas as arestas do grafo para depois reduzir pela metade esse resultado. \par
Matematicamente temos: 
\[m = \frac{1}{2} \cdot \sum_{i=1}^{n} d_{v_{i}} \:, \ \ n = |V|\]


\section*{Questão 2}

\subsection*{1.}
A matriz adjacência associa vértices às linhas e colunas da matriz. Cada posição $a_{ij}$ apresenta valor 1 se existe aresta entre os vértices $i$ e $j$. Caso contrário, apresenta o valor 0. \par 
Nesse sentido a matriz adjacência é $n \times n$, sendo $n$ o numero de vértices. Desse modo, a quantidade de memoria necessária para representar um grafo com tal estrutura é $n^{2}$ bytes ou $\frac{n^{2}}{8}$ bytes, dependendo se o elemento da matriz é um byte ou um bit, respectivamente.

\subsection*{2.}
A lista adjacência associa a cada vértice uma lista de vértices vizinhos. Com isso, cada aresta é contada duas vezes, uma vez em cada lista dos dois vizinhos. \par
Além disso, segundo o enunciado, os vértices são representados por 4 bytes, enquanto os ponteiros ocupam 8 bytes de memória.
Nesse âmbito, a quantidade de memória necessária para representar um grafo com essa estrutura é $4 \cdot |V|* +  2 \cdot 8  |E|$ bytes, ou $4n + 16m$ bytes.

\subsection*{3.}
Já vimos que a quantidade de memória ocupada para utilizar uma matriz adjacência é $n^{2}$ bytes, caso o elemento da matriz for um byte. Também vimos que para a lista adjacência essa ocupação da memória é de $4n + 16m$ bytes. \par
Dessa forma, o enunciado nos pede a inequação a seguir , mas em função da densidade do grafo. 
\[4n+16m < n^{2}\]
Isolando o $m$ da fórmula da densidade temos:
\[d= \frac{m}{ {n \choose 2}} \longrightarrow m = d {n \choose 2} = d \cdot \frac{n(n-1)}{2} \]
Com isso, substituindo $m$ na inequação inicial, temos:
\[4n+16d \cdot \frac{n(n-1)}{2} < n^{2}\]
Finalmente, simplificando encontramos:
\[d < \frac{n-4}{8(n-1)} \: ,\ \ n > 1\]
Observação final: Se $n=1$, a inequação inicial é falsa, portanto a forma simplificada acima não exclui nenhum dos valores possíveis de $n$ e $m$. 

\subsection*{4.}
Utilizando o conhecimento apresentado nos tópicos anteriores, e considerando $n = 25 \cdot 10^{4}$ e $m = 7,6 \cdot 10^{6}$, obtemos:
\begin{itemize}
    \item Matriz de adjacência: $n^{2}= 625 \cdot 10^{8}$
    \item Lista adjacência: $4n+16m = 1,226 \cdot 10^{8}$
\end{itemize}
Neste caso, a lista adjacência é claramente mais eficiente em termos de memória.

\section*{Questão 3}
\subsection*{1.}
Vetores promovem alocação contínua em memória, portanto, para acessar o k-ésimo elemento de um vetor, simplesmente acessamos o endereço calculado por $b+(k-1)*L$, onde $b$ é o endereço base e L é o tamanho de cada elemento. Com isso, a complexidade computacional (de pior caso) desse acesso é O(1), visto que podemos descobrir e alcançar o endereço desejado em tempo constante. \par
No caso da lista encadeada, a alocação é de elemento a elemento, cada elemento possui um ponteiro para o próximo. Dessa forma, para acessar o k-ésimo elemento devemos percorrer por todos seus antecessores. Por conta disso, a complexidade computacional (de pior caso) é, neste caso, O(n). (pior caso ocorre quando $k=n$)

\subsection*{2.}
Em uma tabela hash, a complexidade computacional (de pior caso) de buscar certo item com uma chave é conhecidamente O(1), dada a própria natureza dessa tabela. Ademais, não seria adequado uma linguagem de programação encapsular o acesso à um dicionario, através de uma outra função \textit{getItem(S, k)}, já que todo dicionario possui algum método de, com uma chave k, acessar o dado buscado.


\section*{Questão 4}
Todas as árvores geradoras distintas de $K_{3}$ estão desenhadas a seguir:
\\ \\ 
\begin{tikzpicture}
    \node[shape=circle,draw=black] (A) at (0,2) {1};
    \node[shape=circle,draw=black] (B) at (0,0) {2};
    \node[shape=circle,draw=black] (C) at (2,2) {3};
    
    \path [-] (A) edge node[left] {} (B);
    \path [-] (A) edge node[left] {} (C);

    \node[shape=circle,draw=black] (D) at (4,2) {1};
    \node[shape=circle,draw=black] (E) at (4,0) {2};
    \node[shape=circle,draw=black] (F) at (6,2) {3};
    
    \path [-] (D) edge node[left] {} (E);
    \path [-](E) edge node[left] {} (F);
    
    \node[shape=circle,draw=black] (G) at (8,2) {1};
    \node[shape=circle,draw=black] (H) at (8,0) {2};
    \node[shape=circle,draw=black] (I) at (10,2) {3};
    
    \path [-] (G) edge node[left] {} (I);
    \path [-](H) edge node[left] {} (I);

\end{tikzpicture}

Torna-se evidente, portanto, que existem três árvores geradoras distintas para o grafo $K_{3}$. Fazendo uma análise do grafo $K_{4}$, encontrei 16 árvores geradoras diferentes. \par Após diversas tentativas de deduzir a fórmula para o número de árvores geradoras distintas de $K_{n}$ pesquisei e aprendi sobre a Formula de Cayley’s, que é exatamente o que procurávamos. Ela nos informa que esse número de árvores geradoras distintas de $K_{n}$ é exatamente $n^{(n-2)}$.

\section*{Questão 5}

\subsection*{1.}
Iniciando a busca em largura no vértice $A$, temos que a ordem dos vértices explorados é \{ A, B, D, F, C, E, H, G, I \}

\subsection*{2.}

\begin{tikzpicture}
    \node[shape=circle,draw=black] (A) at (0,0) {A};
    
    \node[shape=circle,draw=black] (B) at (-2,-2) {B};
    \node[shape=circle,draw=black] (D) at (0,-2) {D};
    \node[shape=circle,draw=black] (F) at (2,-2) {F};
    
    \node[shape=circle,draw=black] (C) at (-2,-4) {C};
    \node[shape=circle,draw=black] (E) at (0,-4) {E};
    
    \node[shape=circle,draw=black] (H) at (-2,-6) {H};
    \node[shape=circle,draw=black] (G) at (0,-6) {G};
    
    \node[shape=circle,draw=black] (I) at (-2,-8) {I};
    
    \path [-] (A) edge node[left] {} (B);
    \path [-] (A) edge node[left] {} (D);
    \path [-](A) edge node[left] {} (F);
    
    \path [-](B) edge node[left] {} (C);
    \path [-](D) edge node[left] {} (E);
    
    \path [-](C) edge node[left] {} (H);
    \path [-](E) edge node[left] {} (G);
    
    \path [-](H) edge node[left] {} (I);

\end{tikzpicture}

\subsection*{3.}
Iniciando a busca em profundidade no vértice $A$, temos que a ordem dos vértices explorados é \{ F, H, I, G, E, D, C, B, A \}

\subsection*{4.}

\begin{tikzpicture}
    \node[shape=circle,draw=black] (A) at (0,0) {A};
    \node[shape=circle,draw=black] (B) at (1.5,0) {B};
    \node[shape=circle,draw=black] (C) at (3,0) {C};
    \node[shape=circle,draw=black] (D) at (4.5,0) {D};
    \node[shape=circle,draw=black] (E) at (6,0) {E};

    \node[shape=circle,draw=black] (F) at (7.5,1.5) {F};
    \node[shape=circle,draw=black] (G) at (7.5,-1.5) {G};
    
    \node[shape=circle,draw=black] (I) at (9,-1.5) {I};
    
    \node[shape=circle,draw=black] (H) at (10.5,-1.5) {H};
    
    \path [-] (A) edge node[left] {} (B);
    \path [-] (B) edge node[left] {} (C);
    \path [-] (C) edge node[left] {} (D);
    \path [-] (D) edge node[left] {} (E);
    
    \path [-] (E) edge node[left] {} (F);
    \path [-] (E) edge node[left] {} (G);
    
    \path [-] (G) edge node[left] {} (I);
    \path [-] (I) edge node[left] {} (H);
    
\end{tikzpicture}

\section*{Questão 6}
Para realizar essa questão foi essencial analisar os pseudo-códigos da BFS e DFS apresentados em aula, que serão comentados durante as respostas.
    

\subsection*{1.}
Conhecendo o funcionamento da BFS e DFS apresentados em aula, sabemos que todo vértice, na primeira vez que é ``encontrado", é marcado como descoberto. Também sabemos, pelos dois pseudo-códigos, que após descobrirmos todos os vizinhos  de algum vértice consideramos ele explorado. \par 
A busca em largura descobre, por camadas, todos os vizinhos de um vértice e, portanto, o explora uma vez. Esse processo se repete para os vizinhos e para os vizinhos dos vizinhos até que todos os vértices tenham sido explorados uma única vez. \par
A busca em profundidade descobre, também, todos os vértices de um grafo conexo. Quando essa busca encontra um ``caminho sem saída"  ela considera como explorado o vértice atual e começa a voltar aos anteriores, procurando um novo vértice não descoberto. Quando todos os caminhos possíveis forem descobertos, o grafo conexo terá sido explorado por inteiro uma vez.

\subsection*{2.}
Sabemos, pelo item anterior, que todos os vértices são explorados exatamente uma vez e, em cada exploração, todas as arestas do vértice são examindas. Dessa forma, cada aresta é analisada duas vezes, uma vez por cada vértice conectado a aresta.

\subsection*{3.}
O maior número de elementos que a fila pode ter no BFS é $n-1$, $n$ sendo o número de vértices do grafo. A fila só pode atingir esse valor se a busca iniciar em um vértice do grafo que possui grau $n-1$ e, portanto, todos os outros vértices necessariamente teriam grau 1. Esse seria exclusivamente o único tipo de grafo que permite a ocorrência desse valor máximo da fila.

\subsection*{4.}
O maior número de elementos que a fila pode ter no DFS é $n$, $n$ sendo o número de vértices do grafo. Para isso ocorrer a busca só pode encontrar um ``caminho sem saída" após alcançar todos os vértices do grafo. Desse modo, para o grafo atingir esse valor ele deve ser como uma linha, com o vértice inicial da busca em uma das suas pontas. 

\section*{Questão 7}
O algoritmo abaixo é uma modificação do pseudo-código da BFS, fornecido no material das aulas. Para cada novo vértice descoberto, contamos quantos vizinhos já foram descobertos também. Se a quantidade de vizinhos descobertos for maior ou igual a 2, significa que existe um ciclo no grafo. \par
Este algoritmo também verifica se o grafo é conexo, testando se, no final da execução, existem vértices que não estão marcados. Dessa forma verificamos as duas condições do grafo ser uma árvore e escrevemos esse resultado em uma variável chamada ``arvore". \par
Percebe-se que só imprimimos um dos ciclos do grafo quando o mesmo possui um. Este ciclo sendo o subgrafo com os vértices marcados até o momento.
\begin{enumerate}
    \item Desmarcar todos os vértices
    \item Definir fila Q vazia
    \item Marcar s e inserir s na fila Q
    \item arvore = true
    \item Enquanto Q não estiver vazia \par
    \item \ \ \ \ Retirar v de Q 
    \item \ \ \ \ Para todo vizinho w de v faça
    \item \ \ \ \ var contador = 0
    \item \ \ \ \ \ \ \ \ Se w estiver marcado
    \item \ \ \ \ \ \ \ \ \ \ \ \ contador = contador + 1
    \item \ \ \ \ \ \ \ \ Se contador $\geq$ 2 (existe ciclo)
    \item \ \ \ \ \ \ \ \ \ \ \ \ imprimir subgrafo com vértices marcados
    \item \ \ \ \ \ \ \ \ \ \ \ \ arvore = false
    \item \ \ \ \ \ \ \ \ \ \ \ \ quebrar o loop
    \item \ \ \ \ \ \ \ \ Se w não estiver marcado
    \item \ \ \ \ \ \ \ \ \ \ \ \ marcar w
    \item \ \ \ \ \ \ \ \ \ \ \ \ inserir w em Q
    \item Se existir vértices não marcados
    \item \ \ \ \  arvore = false (grafo desconexo)
    
    
    
\end{enumerate}


\section*{Questão 8}
Para modificar o algoritmo de forma que ele realize o que foi solicitado as linhas 4, 11 e 12 foram adicionadas ao pseudo-código original.
\begin{enumerate}
    \item Desmarcar todos os vértices
    \item Definir fila Q vazia
    \item Marcar s e inserir s na fila Q
    \item Definir nível de s como 0 e pai como \textit{null} 
    \item Enquanto Q não estiver vazia \par
    \item \ \ \ \ Retirar v de Q 
    \item \ \ \ \ Para todo vizinho w de v faça
    \item \ \ \ \ \ \ \ \ Se w não estiver marcado
    \item \ \ \ \ \ \ \ \ \ \ \ \ marcar w
    \item \ \ \ \ \ \ \ \ \ \ \ \ inserir w em Q
    \item \ \ \ \ \ \ \ \ \ \ \ \ Definir pai de w como v
    \item \ \ \ \ \ \ \ \ \ \ \ \ Definir nível de w como o nível de v mais 1
    
\end{enumerate}

\end{document}


á à ã â é è ê ú ó ô õ í ç 
